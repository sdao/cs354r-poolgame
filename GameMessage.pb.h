// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: GameMessage.proto

#ifndef PROTOBUF_GameMessage_2eproto__INCLUDED
#define PROTOBUF_GameMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_GameMessage_2eproto();
void protobuf_AssignDesc_GameMessage_2eproto();
void protobuf_ShutdownFile_GameMessage_2eproto();

class GameMessage;
class Vector3f;
class BallPositions;
class Score;
class HitInfo;

enum GameMessage_Type {
  GameMessage_Type_BALL_POSITIONS = 1,
  GameMessage_Type_SCORE = 2,
  GameMessage_Type_SERVER_RELEASE_CONTROL = 3,
  GameMessage_Type_CLIENT_HIT = 4
};
bool GameMessage_Type_IsValid(int value);
const GameMessage_Type GameMessage_Type_Type_MIN = GameMessage_Type_BALL_POSITIONS;
const GameMessage_Type GameMessage_Type_Type_MAX = GameMessage_Type_CLIENT_HIT;
const int GameMessage_Type_Type_ARRAYSIZE = GameMessage_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameMessage_Type_descriptor();
inline const ::std::string& GameMessage_Type_Name(GameMessage_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameMessage_Type_descriptor(), value);
}
inline bool GameMessage_Type_Parse(
    const ::std::string& name, GameMessage_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameMessage_Type>(
    GameMessage_Type_descriptor(), name, value);
}
enum HitInfo_Strength {
  HitInfo_Strength_LOW = 1,
  HitInfo_Strength_MEDIUM = 2,
  HitInfo_Strength_HIGH = 3
};
bool HitInfo_Strength_IsValid(int value);
const HitInfo_Strength HitInfo_Strength_Strength_MIN = HitInfo_Strength_LOW;
const HitInfo_Strength HitInfo_Strength_Strength_MAX = HitInfo_Strength_HIGH;
const int HitInfo_Strength_Strength_ARRAYSIZE = HitInfo_Strength_Strength_MAX + 1;

const ::google::protobuf::EnumDescriptor* HitInfo_Strength_descriptor();
inline const ::std::string& HitInfo_Strength_Name(HitInfo_Strength value) {
  return ::google::protobuf::internal::NameOfEnum(
    HitInfo_Strength_descriptor(), value);
}
inline bool HitInfo_Strength_Parse(
    const ::std::string& name, HitInfo_Strength* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HitInfo_Strength>(
    HitInfo_Strength_descriptor(), name, value);
}
// ===================================================================

class GameMessage : public ::google::protobuf::Message {
 public:
  GameMessage();
  virtual ~GameMessage();

  GameMessage(const GameMessage& from);

  inline GameMessage& operator=(const GameMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameMessage& default_instance();

  void Swap(GameMessage* other);

  // implements Message ----------------------------------------------

  GameMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameMessage& from);
  void MergeFrom(const GameMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GameMessage_Type Type;
  static const Type BALL_POSITIONS = GameMessage_Type_BALL_POSITIONS;
  static const Type SCORE = GameMessage_Type_SCORE;
  static const Type SERVER_RELEASE_CONTROL = GameMessage_Type_SERVER_RELEASE_CONTROL;
  static const Type CLIENT_HIT = GameMessage_Type_CLIENT_HIT;
  static inline bool Type_IsValid(int value) {
    return GameMessage_Type_IsValid(value);
  }
  static const Type Type_MIN =
    GameMessage_Type_Type_MIN;
  static const Type Type_MAX =
    GameMessage_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    GameMessage_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return GameMessage_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return GameMessage_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return GameMessage_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .GameMessage.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::GameMessage_Type type() const;
  inline void set_type(::GameMessage_Type value);

  // optional .BallPositions ball_positions = 2;
  inline bool has_ball_positions() const;
  inline void clear_ball_positions();
  static const int kBallPositionsFieldNumber = 2;
  inline const ::BallPositions& ball_positions() const;
  inline ::BallPositions* mutable_ball_positions();
  inline ::BallPositions* release_ball_positions();
  inline void set_allocated_ball_positions(::BallPositions* ball_positions);

  // optional .Score score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline const ::Score& score() const;
  inline ::Score* mutable_score();
  inline ::Score* release_score();
  inline void set_allocated_score(::Score* score);

  // optional .HitInfo client_hit = 4;
  inline bool has_client_hit() const;
  inline void clear_client_hit();
  static const int kClientHitFieldNumber = 4;
  inline const ::HitInfo& client_hit() const;
  inline ::HitInfo* mutable_client_hit();
  inline ::HitInfo* release_client_hit();
  inline void set_allocated_client_hit(::HitInfo* client_hit);

  // @@protoc_insertion_point(class_scope:GameMessage)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_ball_positions();
  inline void clear_has_ball_positions();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_client_hit();
  inline void clear_has_client_hit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::BallPositions* ball_positions_;
  ::Score* score_;
  ::HitInfo* client_hit_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_GameMessage_2eproto();
  friend void protobuf_AssignDesc_GameMessage_2eproto();
  friend void protobuf_ShutdownFile_GameMessage_2eproto();

  void InitAsDefaultInstance();
  static GameMessage* default_instance_;
};
// -------------------------------------------------------------------

class Vector3f : public ::google::protobuf::Message {
 public:
  Vector3f();
  virtual ~Vector3f();

  Vector3f(const Vector3f& from);

  inline Vector3f& operator=(const Vector3f& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector3f& default_instance();

  void Swap(Vector3f* other);

  // implements Message ----------------------------------------------

  Vector3f* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector3f& from);
  void MergeFrom(const Vector3f& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // required float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:Vector3f)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  float y_;
  float z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_GameMessage_2eproto();
  friend void protobuf_AssignDesc_GameMessage_2eproto();
  friend void protobuf_ShutdownFile_GameMessage_2eproto();

  void InitAsDefaultInstance();
  static Vector3f* default_instance_;
};
// -------------------------------------------------------------------

class BallPositions : public ::google::protobuf::Message {
 public:
  BallPositions();
  virtual ~BallPositions();

  BallPositions(const BallPositions& from);

  inline BallPositions& operator=(const BallPositions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BallPositions& default_instance();

  void Swap(BallPositions* other);

  // implements Message ----------------------------------------------

  BallPositions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BallPositions& from);
  void MergeFrom(const BallPositions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Vector3f ball = 1;
  inline int ball_size() const;
  inline void clear_ball();
  static const int kBallFieldNumber = 1;
  inline const ::Vector3f& ball(int index) const;
  inline ::Vector3f* mutable_ball(int index);
  inline ::Vector3f* add_ball();
  inline const ::google::protobuf::RepeatedPtrField< ::Vector3f >&
      ball() const;
  inline ::google::protobuf::RepeatedPtrField< ::Vector3f >*
      mutable_ball();

  // @@protoc_insertion_point(class_scope:BallPositions)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Vector3f > ball_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_GameMessage_2eproto();
  friend void protobuf_AssignDesc_GameMessage_2eproto();
  friend void protobuf_ShutdownFile_GameMessage_2eproto();

  void InitAsDefaultInstance();
  static BallPositions* default_instance_;
};
// -------------------------------------------------------------------

class Score : public ::google::protobuf::Message {
 public:
  Score();
  virtual ~Score();

  Score(const Score& from);

  inline Score& operator=(const Score& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Score& default_instance();

  void Swap(Score* other);

  // implements Message ----------------------------------------------

  Score* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Score& from);
  void MergeFrom(const Score& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float host_score = 1;
  inline bool has_host_score() const;
  inline void clear_host_score();
  static const int kHostScoreFieldNumber = 1;
  inline float host_score() const;
  inline void set_host_score(float value);

  // required float client_score = 2;
  inline bool has_client_score() const;
  inline void clear_client_score();
  static const int kClientScoreFieldNumber = 2;
  inline float client_score() const;
  inline void set_client_score(float value);

  // @@protoc_insertion_point(class_scope:Score)
 private:
  inline void set_has_host_score();
  inline void clear_has_host_score();
  inline void set_has_client_score();
  inline void clear_has_client_score();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float host_score_;
  float client_score_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_GameMessage_2eproto();
  friend void protobuf_AssignDesc_GameMessage_2eproto();
  friend void protobuf_ShutdownFile_GameMessage_2eproto();

  void InitAsDefaultInstance();
  static Score* default_instance_;
};
// -------------------------------------------------------------------

class HitInfo : public ::google::protobuf::Message {
 public:
  HitInfo();
  virtual ~HitInfo();

  HitInfo(const HitInfo& from);

  inline HitInfo& operator=(const HitInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HitInfo& default_instance();

  void Swap(HitInfo* other);

  // implements Message ----------------------------------------------

  HitInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HitInfo& from);
  void MergeFrom(const HitInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef HitInfo_Strength Strength;
  static const Strength LOW = HitInfo_Strength_LOW;
  static const Strength MEDIUM = HitInfo_Strength_MEDIUM;
  static const Strength HIGH = HitInfo_Strength_HIGH;
  static inline bool Strength_IsValid(int value) {
    return HitInfo_Strength_IsValid(value);
  }
  static const Strength Strength_MIN =
    HitInfo_Strength_Strength_MIN;
  static const Strength Strength_MAX =
    HitInfo_Strength_Strength_MAX;
  static const int Strength_ARRAYSIZE =
    HitInfo_Strength_Strength_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Strength_descriptor() {
    return HitInfo_Strength_descriptor();
  }
  static inline const ::std::string& Strength_Name(Strength value) {
    return HitInfo_Strength_Name(value);
  }
  static inline bool Strength_Parse(const ::std::string& name,
      Strength* value) {
    return HitInfo_Strength_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .HitInfo.Strength strength = 1;
  inline bool has_strength() const;
  inline void clear_strength();
  static const int kStrengthFieldNumber = 1;
  inline ::HitInfo_Strength strength() const;
  inline void set_strength(::HitInfo_Strength value);

  // required .Vector3f direction = 2;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 2;
  inline const ::Vector3f& direction() const;
  inline ::Vector3f* mutable_direction();
  inline ::Vector3f* release_direction();
  inline void set_allocated_direction(::Vector3f* direction);

  // @@protoc_insertion_point(class_scope:HitInfo)
 private:
  inline void set_has_strength();
  inline void clear_has_strength();
  inline void set_has_direction();
  inline void clear_has_direction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Vector3f* direction_;
  int strength_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_GameMessage_2eproto();
  friend void protobuf_AssignDesc_GameMessage_2eproto();
  friend void protobuf_ShutdownFile_GameMessage_2eproto();

  void InitAsDefaultInstance();
  static HitInfo* default_instance_;
};
// ===================================================================


// ===================================================================

// GameMessage

// required .GameMessage.Type type = 1;
inline bool GameMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameMessage::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::GameMessage_Type GameMessage::type() const {
  return static_cast< ::GameMessage_Type >(type_);
}
inline void GameMessage::set_type(::GameMessage_Type value) {
  assert(::GameMessage_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .BallPositions ball_positions = 2;
inline bool GameMessage::has_ball_positions() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameMessage::set_has_ball_positions() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameMessage::clear_has_ball_positions() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameMessage::clear_ball_positions() {
  if (ball_positions_ != NULL) ball_positions_->::BallPositions::Clear();
  clear_has_ball_positions();
}
inline const ::BallPositions& GameMessage::ball_positions() const {
  return ball_positions_ != NULL ? *ball_positions_ : *default_instance_->ball_positions_;
}
inline ::BallPositions* GameMessage::mutable_ball_positions() {
  set_has_ball_positions();
  if (ball_positions_ == NULL) ball_positions_ = new ::BallPositions;
  return ball_positions_;
}
inline ::BallPositions* GameMessage::release_ball_positions() {
  clear_has_ball_positions();
  ::BallPositions* temp = ball_positions_;
  ball_positions_ = NULL;
  return temp;
}
inline void GameMessage::set_allocated_ball_positions(::BallPositions* ball_positions) {
  delete ball_positions_;
  ball_positions_ = ball_positions;
  if (ball_positions) {
    set_has_ball_positions();
  } else {
    clear_has_ball_positions();
  }
}

// optional .Score score = 3;
inline bool GameMessage::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameMessage::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameMessage::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameMessage::clear_score() {
  if (score_ != NULL) score_->::Score::Clear();
  clear_has_score();
}
inline const ::Score& GameMessage::score() const {
  return score_ != NULL ? *score_ : *default_instance_->score_;
}
inline ::Score* GameMessage::mutable_score() {
  set_has_score();
  if (score_ == NULL) score_ = new ::Score;
  return score_;
}
inline ::Score* GameMessage::release_score() {
  clear_has_score();
  ::Score* temp = score_;
  score_ = NULL;
  return temp;
}
inline void GameMessage::set_allocated_score(::Score* score) {
  delete score_;
  score_ = score;
  if (score) {
    set_has_score();
  } else {
    clear_has_score();
  }
}

// optional .HitInfo client_hit = 4;
inline bool GameMessage::has_client_hit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameMessage::set_has_client_hit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameMessage::clear_has_client_hit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameMessage::clear_client_hit() {
  if (client_hit_ != NULL) client_hit_->::HitInfo::Clear();
  clear_has_client_hit();
}
inline const ::HitInfo& GameMessage::client_hit() const {
  return client_hit_ != NULL ? *client_hit_ : *default_instance_->client_hit_;
}
inline ::HitInfo* GameMessage::mutable_client_hit() {
  set_has_client_hit();
  if (client_hit_ == NULL) client_hit_ = new ::HitInfo;
  return client_hit_;
}
inline ::HitInfo* GameMessage::release_client_hit() {
  clear_has_client_hit();
  ::HitInfo* temp = client_hit_;
  client_hit_ = NULL;
  return temp;
}
inline void GameMessage::set_allocated_client_hit(::HitInfo* client_hit) {
  delete client_hit_;
  client_hit_ = client_hit;
  if (client_hit) {
    set_has_client_hit();
  } else {
    clear_has_client_hit();
  }
}

// -------------------------------------------------------------------

// Vector3f

// required float x = 1;
inline bool Vector3f::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector3f::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector3f::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector3f::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vector3f::x() const {
  return x_;
}
inline void Vector3f::set_x(float value) {
  set_has_x();
  x_ = value;
}

// required float y = 2;
inline bool Vector3f::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector3f::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector3f::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector3f::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vector3f::y() const {
  return y_;
}
inline void Vector3f::set_y(float value) {
  set_has_y();
  y_ = value;
}

// required float z = 3;
inline bool Vector3f::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector3f::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector3f::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector3f::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vector3f::z() const {
  return z_;
}
inline void Vector3f::set_z(float value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// BallPositions

// repeated .Vector3f ball = 1;
inline int BallPositions::ball_size() const {
  return ball_.size();
}
inline void BallPositions::clear_ball() {
  ball_.Clear();
}
inline const ::Vector3f& BallPositions::ball(int index) const {
  return ball_.Get(index);
}
inline ::Vector3f* BallPositions::mutable_ball(int index) {
  return ball_.Mutable(index);
}
inline ::Vector3f* BallPositions::add_ball() {
  return ball_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Vector3f >&
BallPositions::ball() const {
  return ball_;
}
inline ::google::protobuf::RepeatedPtrField< ::Vector3f >*
BallPositions::mutable_ball() {
  return &ball_;
}

// -------------------------------------------------------------------

// Score

// required float host_score = 1;
inline bool Score::has_host_score() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Score::set_has_host_score() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Score::clear_has_host_score() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Score::clear_host_score() {
  host_score_ = 0;
  clear_has_host_score();
}
inline float Score::host_score() const {
  return host_score_;
}
inline void Score::set_host_score(float value) {
  set_has_host_score();
  host_score_ = value;
}

// required float client_score = 2;
inline bool Score::has_client_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Score::set_has_client_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Score::clear_has_client_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Score::clear_client_score() {
  client_score_ = 0;
  clear_has_client_score();
}
inline float Score::client_score() const {
  return client_score_;
}
inline void Score::set_client_score(float value) {
  set_has_client_score();
  client_score_ = value;
}

// -------------------------------------------------------------------

// HitInfo

// required .HitInfo.Strength strength = 1;
inline bool HitInfo::has_strength() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HitInfo::set_has_strength() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HitInfo::clear_has_strength() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HitInfo::clear_strength() {
  strength_ = 1;
  clear_has_strength();
}
inline ::HitInfo_Strength HitInfo::strength() const {
  return static_cast< ::HitInfo_Strength >(strength_);
}
inline void HitInfo::set_strength(::HitInfo_Strength value) {
  assert(::HitInfo_Strength_IsValid(value));
  set_has_strength();
  strength_ = value;
}

// required .Vector3f direction = 2;
inline bool HitInfo::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HitInfo::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HitInfo::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HitInfo::clear_direction() {
  if (direction_ != NULL) direction_->::Vector3f::Clear();
  clear_has_direction();
}
inline const ::Vector3f& HitInfo::direction() const {
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::Vector3f* HitInfo::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) direction_ = new ::Vector3f;
  return direction_;
}
inline ::Vector3f* HitInfo::release_direction() {
  clear_has_direction();
  ::Vector3f* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void HitInfo::set_allocated_direction(::Vector3f* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GameMessage_Type>() {
  return ::GameMessage_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HitInfo_Strength>() {
  return ::HitInfo_Strength_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_GameMessage_2eproto__INCLUDED
